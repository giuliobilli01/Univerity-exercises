# Es c2 del 01/06/2022

Message passing asincorno: send non bloccante e recieve bloccante 





``` Java
// L'asend deve inviare i messaggi in ordine FIFO a un
// determinato destinatario, considerando il fatto che può
// essere utilizzata da diversi processi mittenti con diversi 
// destinatari.
// Supponiamo di avere due funzioni appendId e getMessage per 
// aggiungere l'id del messaggio al messaggio e getMessage per // estrarre il messaggio



// Questa varabile tiene traccia del numero di messaggi 
// a un destinatario
typedef int messageId;

void asend(msg_t msg, pid_t dest) {
  
  // Mappa in cui salviamo l'associazione messageId 
  // al pid del destinatario
  static auto idMap = new Map<pid_t, messageId>;

  // Se il destinatario è nuovo e non ha mai ricevuto
  // un messaggio inseriamo l'associazione nella Map
  if (!idMap.containsKey(dest)) {
    idMap.insert(dest, 0);
  }
  // Per mantenere l'ordine FIFO anche in ricezione
  // bisogna inviare anche il messageId
  appendId(msg, idMap.getValue(dest)++);
  nfasend(msg, sender);
}

// Anche in ricezione bisogna mantenere l'ordine FIFO 
// per farlo si possono inserire in una coda con priorità
// i messaggi in arrivo e si controlla l'ordine.
msg_t arecv(pid_t sender) {

  // Definiamo una mappa in cui salviamo l'associazione tra 
  // id del mittente e la coppia (coda dei messaggi, numero messaggio da ricevere)
  static auto recievingQueues = new Map<pid_t, Pair<PriorityQueue<msg_t>, messageId>>();

  // Se non esiste un'associazione per il pid del mittente
  // vuol dire che va aggiunta
  if (!recievingQueues.containsKey(sender)) {
    recievingQueues.insert(sender, new Pair<PriorityQueue<msg_t>(), 0>>)
  }
  // Il chiamante della arecv rimane fermo finchè non 
  // riceve il messaggio nell'ordine giusto
  while (recievingQueues.getValue(sender).first.isEmpty() || recievingQueue.getValue(sender).first.getMinKey() > recievingQueue.getValue(sender).second) {
    recievingQueue.getValue(sender).first.add(nfarecv(sender));
  }
  // Quando è arrivato il messaggio con l'ordine giusto 
  // dobbiamo rimuoverlo e leggerlo e contemporaneamente
  // incrementare il messageId da aspettare
  msg_t message = recievingQueue.getValue(sender).first.removeMin();
  ++recievingQueue.getValue(sender).second;
  
  return getMessage(message);
}
```